<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>Force-Directed Graph</title>
    <script src="http://d3js.org/d3.v3.js"></script>
    <style type="text/css">

circle.node {
  cursor: pointer;
  stroke: black;
            }
            
.node text {
  pointer-events: none;
  font: 10px sans-serif;
}

line.link {
  fill: black;
  stroke: black;
  stroke-width: 1.5px;
          }

    </style>
  </head>
  <body>
    <div id="chart"></div>
    <script type="text/javascript">

var w = window.innerWidth,
    h = window.innerHeight,
    node,
    link,
    root,
    nodes = [],
    clustlinks = [],
    nodelinks = [],
    colorcategory=d3.scale.category20();

var force = d3.layout.force()
    .on("tick", tick)
    .size([w, h]);

var vis = d3.select("#chart")
  .append("svg:svg")
    .attr("width", w)
    .attr("height", h)
    .attr("pointer-events", "all")
  .append('svg:g')
    .call(d3.behavior.zoom().on("zoom", redraw))
  .append('svg:g');

vis.append('svg:rect')
    .attr('width', w)
    .attr('height', h)
    .attr('fill', 'white');



function redraw() {
  vis.attr("transform",
      "translate(" + d3.event.translate + ")"
      + " scale(" + d3.event.scale + ")");
}  

 
d3.json("ClusteredGraph1d.json", function(json) {
  root = json;
  flatten(root);
 clustlinks = eval(json.clustlinks);
for(var i=0;i<clustlinks.length;i++)
	if(nodes.indexOf(clustlinks[i].source)==-1)
		clustlinks.splice(i); 
  for(var i=0;i<nodes.length;i++) 
	  nodelinks.push(eval(json["cluster"+i]));
  	         
  update();
  
});


function update() {
  // Restart the force layout.
  force
      .nodes(nodes)
      .links(clustlinks)
      .linkStrength(function(d){if(d.target.name[0]=="c"){return 0.003;} else return 0.5;})
      .linkDistance(30)
      .gravity(0.5)
      .charge(function(d){if(d.name[0]=="c"){return -300;} else return -300;})
      .start();

  // Update the links…
  link = vis.selectAll("line.link")
      .data(clustlinks, function(d) { return d.target.name; });

  // Enter any new links.
  link.enter().append("svg:line",".node")
      .attr("class", "link")
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; })
      .attr("source",function(d){ return d.source.name;})
      .attr("target",function(d){ return d.target.name;})
      .style("stroke",function(d){if(d.source.name[0]=="c" && d.target.name[0]!="c") return "none"; else return "black";})
      .style("stroke-width", function(d){ return (d.value/100)*2; });
      
  link.append("title")
      .text(function(d) { return d.source.name +"to"+ d.target.name; });

  // Exit any old links.
  link.exit().remove();

  // Update the nodes…
  node = vis.selectAll("circle.node")
      .data(nodes, function(d) { return d.id; })
      .style("fill", color);

  // Enter any new nodes.
  node.enter().append("svg:circle")
      .attr("class", "node")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; })
      .attr("r", function(d) { return 10; })
      .attr("name", function(d){ return d.name; })
      .style("fill", color);
  
      
  node.on("click", click)
      //.on("mouseover", newcolor)
      .call(force.drag);
      
   //node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
   
    node.append("title")
      .text(function(d) { return d.name; });
      

  // Exit any old nodes.
  node.exit().remove();

}


function tick() {
  link.attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });
	
  node.attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
     // .on("doubleclick", newcolor);
      

}

// Color leaf nodes orange, and packages white or blue.
function color(d) { 	
  var code;
  if(d.parent=="flare") code="#3fada8";
  else{ code=colorcategory(d.parent.slice(7));

}
  function CC(){return code;}
  var teal = d3.rgb(CC());
  if(d.name == "cluster22") return teal.brighter(2);
  if(d.name == "19078") return teal.brighter(2);
  if(d.name == "19079") return teal.brighter(1);
  if(d.color) return d.color;
  else
  return d.children ? teal : d.children ? teal.darker(2) : teal.darker(2);
}

function newcolor(d) {
  d.color="Red";
  update();
}

// Toggle children on click.
function click(d) {

  function check(child){ 
        if(nodes.indexOf(child)==-1) return true;
        else return false;
                       }

 if(check(d.children[0])){
    d.color=color(d);
    flatten(d);
                         } 
  else { 
    d.color=color(d);
    deflatten(d);
       }
  update();

}
function deflatten(node) {
 var i=0,parent=node;
 var temp = parseInt(parent.name.slice(7));
 var node_arr=nodelinks[temp];
 var s = [];
 var t = [];
 function recurse(child) {
    
    if (!child.id) child.id = child.name;
    if(nodes.indexOf(child)!=-1){
        nodes.splice(nodes.indexOf(child),1);
        if(parent.name!="flare") {
		//clustlinks.splice(clustlinks.indexOf(eval({"source":parent,"target":child,"value":50})),1);     
		for(var i=0;i<node_arr.length;i++){
		if(node_arr[i].source==child.name)
                          s[i]=child;
		if(node_arr[i].target==child.name)
                          t[i]=child;
					  }	 
				 }
                               }
                        }
 if (node.children) node.children.forEach(recurse);
if(node.name[0]=="c"){
	for(var i=0;i<node_arr.length;i++)
		clustlinks.splice(clustlinks.indexOf(eval({"source":s[i],"target":t[i],"value":50}))); 
		     }
}




// Returns a list of all nodes under the root.
function flatten(node) {
 var i=0,parent=node,j=0;
 var temp = parseInt(parent.name.slice(7));
 var node_arr=nodelinks[temp];

 var s = [];
 var t = [];
 var ParentChild = [];
 function recurse(child) {
    j++;
	
    if(parent.name=="flare"){
	if(child.children.length>50 || child.children.length<25)
		 return;
   
  // alert(child.name+" no of children:"+child.children.length);
			    }		
   // if(parseInt(child.name)>500) return;	  	  
    if(!child.id) child.id = child.name;
    if(!child.parent) child.parent=parent.name;
    if(nodes.indexOf(child)==-1){
        nodes.splice(parseInt(child.id),0,child);
        if(parent.name!="flare"){
            for(var i=0;i<node_arr.length;i++){
		if(node_arr[i].source==child.name)
                          s[i]=child;
		if(node_arr[i].target==child.name)
                          t[i]=child;
		
					      }	 
		//alert(nodes.indexOf(child)+" "+child.name); 
     
         
                                }
                                }
                          }
    if(node.children) node.children.forEach(recurse);
    if(node.name[0]=="c")
 	for(var i=0;i<node_arr.length;i++)
		if(typeof(s[i])!="undefined" && typeof(t[i])!="undefined")
			clustlinks.push(eval({"source":s[i],"target":t[i],"value":50})); 

		     

}
    </script>
  </body>
</html>
